"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/context/tracking-context.tsx":
/*!******************************************!*\
  !*** ./app/context/tracking-context.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackingProvider: function() { return /* binding */ TrackingProvider; },\n/* harmony export */   useUserTracking: function() { return /* binding */ useUserTracking; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* __next_internal_client_entry_do_not_use__ TrackingProvider,useUserTracking auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst TrackingContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst TrackingProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [trackingData, setTrackingData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Referencias para tracking (UNA SOLA INSTANCIA)\n    const startTime = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Date.now());\n    const totalActiveTime = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const lastActivityTime = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(Date.now());\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const sessionId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)));\n    const visitUid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"visit_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 15)));\n    const mouseMovementCount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const clickCount = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const scrollDepth = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const pageViews = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(1);\n    const isSending = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false) // Evitar múltiples inicializaciones\n    ;\n    const hasSentBeforeUnload = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false) // Evitar envíos duplicados en beforeunload\n    ;\n    const hasSentInitTracking = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false) // Evitar envíos duplicados de init tracking\n    ;\n    // Función para obtener IP\n    const getIPAddress = async ()=>{\n        try {\n            const response = await fetch(\"https://api.ipify.org?format=json\");\n            const data = await response.json();\n            return data.ip;\n        } catch (error) {\n            console.warn(\"No se pudo obtener la IP:\", error);\n            return undefined;\n        }\n    };\n    // Función para obtener la localidad a partir de la IP usando ipinfo.io\n    const getLocalidad = async ()=>{\n        try {\n            const response = await fetch(\"https://ipinfo.io/json\");\n            const data = await response.json();\n            return data.city;\n        } catch (error) {\n            console.warn(\"No se pudo obtener la localidad:\", error);\n            return undefined;\n        }\n    };\n    // Función para obtener información de conexión\n    const getConnectionInfo = ()=>{\n        if (\"connection\" in navigator) {\n            const connection = navigator.connection;\n            return {\n                connectionType: connection.effectiveType || connection.type,\n                effectiveType: connection.effectiveType,\n                downlink: connection.downlink,\n                rtt: connection.rtt\n            };\n        }\n        return {};\n    };\n    // Función para detectar dispositivo\n    const getDeviceInfo = ()=>{\n        const userAgent = navigator.userAgent;\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);\n        const isTablet = /iPad|Android(?=.*\\bMobile\\b)(?=.*\\bSafari\\b)/i.test(userAgent);\n        const isDesktop = !isMobile && !isTablet;\n        return {\n            isMobile,\n            isTablet,\n            isDesktop,\n            touchSupport: \"ontouchstart\" in window\n        };\n    };\n    // Función para obtener datos completos de tracking\n    const getTrackingData = async ()=>{\n        const ipAddress = await getIPAddress();\n        return {\n            // UID único de la visita\n            visitUid: visitUid.current,\n            // Información del navegador\n            userAgent: navigator.userAgent,\n            language: navigator.language,\n            platform: navigator.platform,\n            cookieEnabled: navigator.cookieEnabled,\n            doNotTrack: navigator.doNotTrack,\n            // Información de la pantalla\n            screenWidth: window.screen.width,\n            screenHeight: window.screen.height,\n            viewportWidth: window.innerWidth,\n            viewportHeight: window.innerHeight,\n            colorDepth: window.screen.colorDepth,\n            pixelRatio: window.devicePixelRatio,\n            // Información de la conexión\n            ...getConnectionInfo(),\n            // Información de ubicación\n            ipAddress,\n            city: await getLocalidad(),\n            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n            // Información de tiempo\n            sessionStartTime: startTime.current,\n            totalActiveTime: isActive.current ? totalActiveTime.current + (Date.now() - lastActivityTime.current) : totalActiveTime.current,\n            lastActivityTime: lastActivityTime.current,\n            // Información de interacciones\n            pageViews: pageViews.current,\n            clicks: clickCount.current,\n            scrollDepth: scrollDepth.current,\n            mouseMovements: mouseMovementCount.current,\n            // Información de la página\n            referrer: document.referrer,\n            currentUrl: window.location.href,\n            // Información del dispositivo\n            ...getDeviceInfo(),\n            // Información adicional\n            sessionId: sessionId.current,\n            timestamp: Date.now()\n        };\n    };\n    // Función para enviar datos de tracking\n    const sendTrackingData = async ()=>{\n        // Evitar llamadas duplicadas\n        if (isSending.current) {\n            console.log(\"Ya hay una llamada de tracking en progreso, saltando...\");\n            return;\n        }\n        try {\n            isSending.current = true;\n            hasSentBeforeUnload.current = true // Marcar que ya se envió\n            ;\n            // Resetear el flag después de 5 segundos\n            setTimeout(()=>{\n                hasSentBeforeUnload.current = false;\n                console.log(\"Flag hasSentBeforeUnload reseteado\");\n            }, 5000);\n            const data = await getTrackingData();\n            const endpoint = \"http://localhost:3003/send-event\";\n            const accessToken = \"EAAOHUgAkJWEBPHk7PAlWlSFEaIW3UBDhGn87Q6DipWvRt0gXptWxF0N9bqEvGdayqRiC3OClsQbztOXhQhk4vXTXfNv12vFE2yQfeQii5CEGXkmgpZCeG1dwKYq83anh4zvUHMrXnqhILBZBbDDkzsfy2s8eD0ZBz8gL1oy60rfzpaC7CeT8Gq9EkQ4luk6OQZDZD\";\n            const pixelId = \"1374845580367644\";\n            if (!endpoint) {\n                throw new Error(\"Endpoint no configurado\");\n            }\n            if (!accessToken) {\n                throw new Error(\"Access Token no configurado\");\n            }\n            if (!pixelId) {\n                throw new Error(\"Pixel ID no configurado\");\n            }\n            const payload = {\n                trackingData: data,\n                events: events,\n                access_token: accessToken,\n                pixel_id: pixelId\n            };\n            const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(endpoint, \"/tracking\"), payload, {\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                timeout: 10000\n            });\n            console.log(\"Datos de tracking enviados exitosamente:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error enviando datos de tracking:\", error);\n            // Fallback: guardar en localStorage\n            saveToLocalStorage();\n            throw error;\n        } finally{\n            isSending.current = false;\n        }\n    };\n    // Función para guardar en localStorage como fallback\n    const saveToLocalStorage = ()=>{\n        try {\n            getTrackingData().then((trackingData)=>{\n                const existingData = localStorage.getItem(\"trackingData\");\n                const data = existingData ? JSON.parse(existingData) : [];\n                data.push({\n                    trackingData,\n                    events,\n                    timestamp: Date.now()\n                });\n                localStorage.setItem(\"trackingData\", JSON.stringify(data));\n            });\n        } catch (error) {\n            console.error(\"Error guardando en localStorage:\", error);\n        }\n    };\n    // Función para enviar init tracking\n    const sendInitTracking = async ()=>{\n        // Evitar envíos duplicados\n        if (hasSentInitTracking.current) {\n            console.log(\"Init tracking ya fue enviado, saltando...\");\n            return;\n        }\n        try {\n            hasSentInitTracking.current = true;\n            const endpoint = \"http://localhost:3003/send-event\";\n            const accessToken = \"EAAOHUgAkJWEBPHk7PAlWlSFEaIW3UBDhGn87Q6DipWvRt0gXptWxF0N9bqEvGdayqRiC3OClsQbztOXhQhk4vXTXfNv12vFE2yQfeQii5CEGXkmgpZCeG1dwKYq83anh4zvUHMrXnqhILBZBbDDkzsfy2s8eD0ZBz8gL1oy60rfzpaC7CeT8Gq9EkQ4luk6OQZDZD\";\n            const pixelId = \"1374845580367644\";\n            if (!endpoint) {\n                throw new Error(\"Endpoint no configurado\");\n            }\n            const payload = {\n                visitUid: visitUid.current,\n                sessionId: sessionId.current,\n                page_id: pixelId || null,\n                timestamp: Date.now(),\n                access_token: accessToken || null,\n                pixel_id: pixelId || null\n            };\n            const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(endpoint, \"/init-tracking\"), payload, {\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                timeout: 10000\n            });\n            console.log(\"Init tracking enviado exitosamente:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error enviando init tracking:\", error);\n            // Fallback: guardar en localStorage\n            saveInitToLocalStorage();\n            throw error;\n        }\n    };\n    // Función para guardar init tracking en localStorage como fallback\n    const saveInitToLocalStorage = ()=>{\n        try {\n            const accessToken = \"EAAOHUgAkJWEBPHk7PAlWlSFEaIW3UBDhGn87Q6DipWvRt0gXptWxF0N9bqEvGdayqRiC3OClsQbztOXhQhk4vXTXfNv12vFE2yQfeQii5CEGXkmgpZCeG1dwKYq83anh4zvUHMrXnqhILBZBbDDkzsfy2s8eD0ZBz8gL1oy60rfzpaC7CeT8Gq9EkQ4luk6OQZDZD\";\n            const pixelId = \"1374845580367644\";\n            const initData = {\n                visitUid: visitUid.current,\n                sessionId: sessionId.current,\n                page_id: pixelId || null,\n                timestamp: Date.now(),\n                access_token: accessToken || null,\n                pixel_id: pixelId || null\n            };\n            const existingData = localStorage.getItem(\"initTrackingData\");\n            const data = existingData ? JSON.parse(existingData) : [];\n            data.push({\n                ...initData,\n                created_at: new Date().toISOString()\n            });\n            localStorage.setItem(\"initTrackingData\", JSON.stringify(data));\n            console.log(\"Init tracking guardado en localStorage como fallback\");\n        } catch (error) {\n            console.error(\"Error guardando init tracking en localStorage:\", error);\n        }\n    };\n    // Función para agregar evento\n    const addEvent = function(type) {\n        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const event = {\n            type,\n            data,\n            timestamp: Date.now(),\n            visitUid: visitUid.current\n        };\n        setEvents((prev)=>[\n                ...prev,\n                event\n            ]);\n    };\n    // Función para incrementar page views\n    const incrementPageViews = ()=>{\n        pageViews.current++;\n    };\n    // Función para obtener session ID\n    const getSessionId = ()=>{\n        return sessionId.current;\n    };\n    // Función para obtener visit UID\n    const getVisitUid = ()=>{\n        return visitUid.current;\n    };\n    // Función para obtener eventos\n    const getEvents = ()=>{\n        return events;\n    };\n    // Timer functions\n    const startTimer = ()=>{\n        if (!isActive.current) {\n            isActive.current = true;\n            lastActivityTime.current = Date.now();\n        }\n    };\n    const stopTimer = ()=>{\n        if (isActive.current) {\n            totalActiveTime.current += Date.now() - lastActivityTime.current;\n            isActive.current = false;\n        }\n    };\n    // Update scroll depth\n    const updateScrollDepth = ()=>{\n        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n        const docHeight = document.documentElement.scrollHeight - window.innerHeight;\n        const scrollPercent = scrollTop / docHeight * 100;\n        scrollDepth.current = Math.max(scrollDepth.current, scrollPercent);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Evitar múltiples inicializaciones\n        if (isInitialized.current) {\n            return;\n        }\n        isInitialized.current = true;\n        console.log(\"Inicializando Tracking Provider...\");\n        // Enviar init tracking inmediatamente cuando el usuario entra\n        sendInitTracking().catch((error)=>{\n            console.error(\"Error en init tracking:\", error);\n        });\n        // Obtener datos iniciales\n        getTrackingData().then(setTrackingData);\n        // Timer events\n        const handleFocus = ()=>{\n            startTimer();\n            addEvent(\"focus\");\n        };\n        const handleBlur = ()=>{\n            stopTimer();\n            addEvent(\"blur\");\n        };\n        const handleVisibilityChange = ()=>{\n            if (document.visibilityState === \"hidden\") {\n                stopTimer();\n            } else {\n                startTimer();\n            }\n        };\n        // Scroll tracking\n        let scrollTimeout;\n        const handleScroll = ()=>{\n            updateScrollDepth();\n            clearTimeout(scrollTimeout);\n            scrollTimeout = setTimeout(()=>{\n                addEvent(\"scroll\", {\n                    scrollDepth: scrollDepth.current\n                });\n            }, 100);\n        };\n        // Click tracking\n        const handleClick = ()=>{\n            clickCount.current++;\n            addEvent(\"click\", {\n                clicks: clickCount.current\n            });\n        };\n        // Mouse movement tracking (throttled)\n        let mouseTimeout;\n        const handleMouseMove = ()=>{\n            mouseMovementCount.current++;\n            clearTimeout(mouseTimeout);\n            mouseTimeout = setTimeout(()=>{\n                if (mouseMovementCount.current % 10 === 0) {\n                    addEvent(\"scroll\", {\n                        mouseMovements: mouseMovementCount.current\n                    });\n                }\n            }, 1000);\n        };\n        // Before unload\n        const handleBeforeUnload = ()=>{\n            stopTimer();\n            // Solo enviar si no se está enviando ya Y no se ha enviado recientemente\n            if (!isSending.current && !hasSentBeforeUnload.current) {\n                console.log(\"Enviando tracking data en beforeunload...\");\n                sendTrackingData();\n            } else {\n                console.log(\"Saltando env\\xedo en beforeunload (ya se envi\\xf3 recientemente)\");\n            }\n        };\n        // Page load time\n        const handleLoad = ()=>{\n            if (window.performance && window.performance.timing) {\n                const loadTime = window.performance.timing.loadEventEnd - window.performance.timing.navigationStart;\n                addEvent(\"page_view\", {\n                    pageLoadTime: loadTime\n                });\n            }\n        };\n        // Event listeners\n        window.addEventListener(\"focus\", handleFocus);\n        window.addEventListener(\"blur\", handleBlur);\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n        window.addEventListener(\"scroll\", handleScroll);\n        window.addEventListener(\"click\", handleClick);\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        window.addEventListener(\"beforeunload\", handleBeforeUnload);\n        window.addEventListener(\"load\", handleLoad);\n        // Actualizar datos cada 30 segundos\n        const interval = setInterval(async ()=>{\n            const data = await getTrackingData();\n            setTrackingData(data);\n        }, 30000);\n        return ()=>{\n            console.log(\"Limpiando Tracking Provider...\");\n            clearInterval(interval);\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"blur\", handleBlur);\n            document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"scroll\", handleScroll);\n            window.removeEventListener(\"click\", handleClick);\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n            window.removeEventListener(\"load\", handleLoad);\n            // Solo enviar datos al desmontar si no se está enviando ya Y no se ha enviado recientemente\n            if (!isSending.current && !hasSentBeforeUnload.current) {\n                console.log(\"Enviando tracking data en cleanup...\");\n                sendTrackingData();\n            } else {\n                console.log(\"Saltando env\\xedo en cleanup (ya se envi\\xf3 recientemente)\");\n            }\n        };\n    }, []);\n    const value = {\n        trackingData,\n        sendTrackingData,\n        sendInitTracking,\n        incrementPageViews,\n        getSessionId,\n        getVisitUid,\n        getEvents\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(TrackingContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/ramiroatlantic/Desktop/CROSSUP/landings-lautaro/landings-RA/landing-seven/app/context/tracking-context.tsx\",\n        lineNumber: 551,\n        columnNumber: 5\n    }, undefined);\n};\n_s(TrackingProvider, \"rH73X92pGi31FhzghGEXGWqljO0=\");\n_c = TrackingProvider;\n// Hook simplificado que usa el context\nconst useUserTracking = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(TrackingContext);\n    if (context === undefined) {\n        throw new Error(\"useUserTracking debe ser usado dentro de TrackingProvider\");\n    }\n    return context;\n};\n_s1(useUserTracking, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TrackingProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb250ZXh0L3RyYWNraW5nLWNvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRXFHO0FBQzVFO0FBNkV6QixNQUFNTyxnQ0FBa0JOLG9EQUFhQSxDQUFrQ087QUFFaEUsTUFBTUMsbUJBQXNEO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUM5RSxNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHVCwrQ0FBUUEsQ0FBMEI7SUFDMUUsTUFBTSxDQUFDVSxRQUFRQyxVQUFVLEdBQUdYLCtDQUFRQSxDQUFrQixFQUFFO0lBRXhELGlEQUFpRDtJQUNqRCxNQUFNWSxZQUFZViw2Q0FBTUEsQ0FBU1csS0FBS0MsR0FBRztJQUN6QyxNQUFNQyxrQkFBa0JiLDZDQUFNQSxDQUFTO0lBQ3ZDLE1BQU1jLG1CQUFtQmQsNkNBQU1BLENBQVNXLEtBQUtDLEdBQUc7SUFDaEQsTUFBTUcsV0FBV2YsNkNBQU1BLENBQVU7SUFDakMsTUFBTWdCLFlBQVloQiw2Q0FBTUEsQ0FBUyxHQUFpQmlCLE9BQWROLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0ssS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDdkYsTUFBTUMsV0FBV3JCLDZDQUFNQSxDQUFTLFNBQXVCaUIsT0FBZE4sS0FBS0MsR0FBRyxJQUFHLEtBQTRDLE9BQXpDSyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRztJQUM1RixNQUFNRSxxQkFBcUJ0Qiw2Q0FBTUEsQ0FBUztJQUMxQyxNQUFNdUIsYUFBYXZCLDZDQUFNQSxDQUFTO0lBQ2xDLE1BQU13QixjQUFjeEIsNkNBQU1BLENBQVM7SUFDbkMsTUFBTXlCLFlBQVl6Qiw2Q0FBTUEsQ0FBUztJQUNqQyxNQUFNMEIsWUFBWTFCLDZDQUFNQSxDQUFVO0lBQ2xDLE1BQU0yQixnQkFBZ0IzQiw2Q0FBTUEsQ0FBVSxPQUFPLG9DQUFv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TyxNQUFNd0I7WUFDbkJsRCxnQkFBZ0IwQjtRQUNsQixHQUFHO1FBRUgsT0FBTztZQUNMSSxRQUFRc0QsR0FBRyxDQUFDO1lBQ1p3RSxjQUFjRjtZQUNkekcsT0FBTzRHLG1CQUFtQixDQUFDLFNBQVN0QjtZQUNwQ3RGLE9BQU80RyxtQkFBbUIsQ0FBQyxRQUFRckI7WUFDbkMxRCxTQUFTK0UsbUJBQW1CLENBQUMsb0JBQW9CcEI7WUFDakR4RixPQUFPNEcsbUJBQW1CLENBQUMsVUFBVWpCO1lBQ3JDM0YsT0FBTzRHLG1CQUFtQixDQUFDLFNBQVNmO1lBQ3BDN0YsT0FBTzRHLG1CQUFtQixDQUFDLGFBQWFiO1lBQ3hDL0YsT0FBTzRHLG1CQUFtQixDQUFDLGdCQUFnQlo7WUFDM0NoRyxPQUFPNEcsbUJBQW1CLENBQUMsUUFBUVg7WUFFbkMsNEZBQTRGO1lBQzVGLElBQUksQ0FBQy9ILFVBQVVpQyxPQUFPLElBQUksQ0FBQy9CLG9CQUFvQitCLE9BQU8sRUFBRTtnQkFDdER0QixRQUFRc0QsR0FBRyxDQUFDO2dCQUNaRDtZQUNGLE9BQU87Z0JBQ0xyRCxRQUFRc0QsR0FBRyxDQUFDO1lBQ2Q7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU0wRSxRQUE2QjtRQUNqQy9KO1FBQ0FvRjtRQUNBNEI7UUFDQVM7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtJQUVBLHFCQUNFLDhEQUFDaEksZ0JBQWdCb0ssUUFBUTtRQUFDRCxPQUFPQTtrQkFDOUJoSzs7Ozs7O0FBR1AsRUFBQztHQXhkWUQ7S0FBQUE7QUEwZGIsdUNBQXVDO0FBQ2hDLE1BQU1tSyxrQkFBa0I7O0lBQzdCLE1BQU1DLFVBQVUzSyxpREFBVUEsQ0FBQ0s7SUFDM0IsSUFBSXNLLFlBQVlySyxXQUFXO1FBQ3pCLE1BQU0sSUFBSWtHLE1BQU07SUFDbEI7SUFDQSxPQUFPbUU7QUFDVCxFQUFDO0lBTllEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb250ZXh0L3RyYWNraW5nLWNvbnRleHQudHN4PzUyMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHR5cGUgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclRyYWNraW5nRGF0YSB7XG4gIC8vIFVJRCDDum5pY28gZGUgbGEgdmlzaXRhXG4gIHZpc2l0VWlkOiBzdHJpbmdcbiAgXG4gIC8vIEluZm9ybWFjacOzbiBkZWwgbmF2ZWdhZG9yXG4gIHVzZXJBZ2VudDogc3RyaW5nXG4gIGxhbmd1YWdlOiBzdHJpbmdcbiAgcGxhdGZvcm06IHN0cmluZ1xuICBjb29raWVFbmFibGVkOiBib29sZWFuXG4gIGRvTm90VHJhY2s6IHN0cmluZyB8IG51bGxcbiAgXG4gIC8vIEluZm9ybWFjacOzbiBkZSBsYSBwYW50YWxsYVxuICBzY3JlZW5XaWR0aDogbnVtYmVyXG4gIHNjcmVlbkhlaWdodDogbnVtYmVyXG4gIHZpZXdwb3J0V2lkdGg6IG51bWJlclxuICB2aWV3cG9ydEhlaWdodDogbnVtYmVyXG4gIGNvbG9yRGVwdGg6IG51bWJlclxuICBwaXhlbFJhdGlvOiBudW1iZXJcbiAgXG4gIC8vIEluZm9ybWFjacOzbiBkZSBsYSBjb25leGnDs25cbiAgY29ubmVjdGlvblR5cGU/OiBzdHJpbmdcbiAgZWZmZWN0aXZlVHlwZT86IHN0cmluZ1xuICBkb3dubGluaz86IG51bWJlclxuICBydHQ/OiBudW1iZXJcbiAgXG4gIC8vIEluZm9ybWFjacOzbiBkZSB1YmljYWNpw7NuXG4gIGlwQWRkcmVzcz86IHN0cmluZ1xuICBjb3VudHJ5Pzogc3RyaW5nXG4gIGNpdHk/OiBzdHJpbmdcbiAgdGltZXpvbmU6IHN0cmluZ1xuICBcbiAgLy8gSW5mb3JtYWNpw7NuIGRlIHRpZW1wb1xuICBzZXNzaW9uU3RhcnRUaW1lOiBudW1iZXJcbiAgdG90YWxBY3RpdmVUaW1lOiBudW1iZXJcbiAgbGFzdEFjdGl2aXR5VGltZTogbnVtYmVyXG4gIFxuICAvLyBJbmZvcm1hY2nDs24gZGUgaW50ZXJhY2Npb25lc1xuICBwYWdlVmlld3M6IG51bWJlclxuICBjbGlja3M6IG51bWJlclxuICBzY3JvbGxEZXB0aDogbnVtYmVyXG4gIG1vdXNlTW92ZW1lbnRzOiBudW1iZXJcbiAgXG4gIC8vIEluZm9ybWFjacOzbiBkZSBsYSBww6FnaW5hXG4gIHJlZmVycmVyOiBzdHJpbmdcbiAgY3VycmVudFVybDogc3RyaW5nXG4gIHBhZ2VMb2FkVGltZT86IG51bWJlclxuICBcbiAgLy8gSW5mb3JtYWNpw7NuIGRlbCBkaXNwb3NpdGl2b1xuICBpc01vYmlsZTogYm9vbGVhblxuICBpc1RhYmxldDogYm9vbGVhblxuICBpc0Rlc2t0b3A6IGJvb2xlYW5cbiAgdG91Y2hTdXBwb3J0OiBib29sZWFuXG4gIFxuICAvLyBJbmZvcm1hY2nDs24gYWRpY2lvbmFsXG4gIHNlc3Npb25JZDogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tpbmdFdmVudCB7XG4gIHR5cGU6ICdwYWdlX3ZpZXcnIHwgJ2NsaWNrJyB8ICdzY3JvbGwnIHwgJ2ZvY3VzJyB8ICdibHVyJyB8ICdzZXNzaW9uX2VuZCdcbiAgZGF0YTogUGFydGlhbDxVc2VyVHJhY2tpbmdEYXRhPlxuICB0aW1lc3RhbXA6IG51bWJlclxuICB2aXNpdFVpZDogc3RyaW5nXG59XG5cbmludGVyZmFjZSBUcmFja2luZ0NvbnRleHRUeXBlIHtcbiAgdHJhY2tpbmdEYXRhOiBVc2VyVHJhY2tpbmdEYXRhIHwgbnVsbFxuICBzZW5kVHJhY2tpbmdEYXRhOiAoKSA9PiBQcm9taXNlPGFueT5cbiAgc2VuZEluaXRUcmFja2luZzogKCkgPT4gUHJvbWlzZTxhbnk+XG4gIGluY3JlbWVudFBhZ2VWaWV3czogKCkgPT4gdm9pZFxuICBnZXRTZXNzaW9uSWQ6ICgpID0+IHN0cmluZ1xuICBnZXRWaXNpdFVpZDogKCkgPT4gc3RyaW5nXG4gIGdldEV2ZW50czogKCkgPT4gVHJhY2tpbmdFdmVudFtdXG59XG5cbmNvbnN0IFRyYWNraW5nQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VHJhY2tpbmdDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxuXG5leHBvcnQgY29uc3QgVHJhY2tpbmdQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbdHJhY2tpbmdEYXRhLCBzZXRUcmFja2luZ0RhdGFdID0gdXNlU3RhdGU8VXNlclRyYWNraW5nRGF0YSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZTxUcmFja2luZ0V2ZW50W10+KFtdKVxuICBcbiAgLy8gUmVmZXJlbmNpYXMgcGFyYSB0cmFja2luZyAoVU5BIFNPTEEgSU5TVEFOQ0lBKVxuICBjb25zdCBzdGFydFRpbWUgPSB1c2VSZWY8bnVtYmVyPihEYXRlLm5vdygpKVxuICBjb25zdCB0b3RhbEFjdGl2ZVRpbWUgPSB1c2VSZWY8bnVtYmVyPigwKVxuICBjb25zdCBsYXN0QWN0aXZpdHlUaW1lID0gdXNlUmVmPG51bWJlcj4oRGF0ZS5ub3coKSlcbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VSZWY8Ym9vbGVhbj4odHJ1ZSlcbiAgY29uc3Qgc2Vzc2lvbklkID0gdXNlUmVmPHN0cmluZz4oYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YClcbiAgY29uc3QgdmlzaXRVaWQgPSB1c2VSZWY8c3RyaW5nPihgdmlzaXRfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxNSl9YClcbiAgY29uc3QgbW91c2VNb3ZlbWVudENvdW50ID0gdXNlUmVmPG51bWJlcj4oMClcbiAgY29uc3QgY2xpY2tDb3VudCA9IHVzZVJlZjxudW1iZXI+KDApXG4gIGNvbnN0IHNjcm9sbERlcHRoID0gdXNlUmVmPG51bWJlcj4oMClcbiAgY29uc3QgcGFnZVZpZXdzID0gdXNlUmVmPG51bWJlcj4oMSlcbiAgY29uc3QgaXNTZW5kaW5nID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKVxuICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKSAvLyBFdml0YXIgbcO6bHRpcGxlcyBpbmljaWFsaXphY2lvbmVzXG4gIGNvbnN0IGhhc1NlbnRCZWZvcmVVbmxvYWQgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpIC8vIEV2aXRhciBlbnbDrW9zIGR1cGxpY2Fkb3MgZW4gYmVmb3JldW5sb2FkXG4gIGNvbnN0IGhhc1NlbnRJbml0VHJhY2tpbmcgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpIC8vIEV2aXRhciBlbnbDrW9zIGR1cGxpY2Fkb3MgZGUgaW5pdCB0cmFja2luZ1xuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBJUFxuICBjb25zdCBnZXRJUEFkZHJlc3MgPSBhc3luYyAoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuaXBpZnkub3JnP2Zvcm1hdD1qc29uJylcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiBkYXRhLmlwXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gc2UgcHVkbyBvYnRlbmVyIGxhIElQOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBsYSBsb2NhbGlkYWQgYSBwYXJ0aXIgZGUgbGEgSVAgdXNhbmRvIGlwaW5mby5pb1xuICBjb25zdCBnZXRMb2NhbGlkYWQgPSBhc3luYyAoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9pcGluZm8uaW8vanNvbicpXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gZGF0YS5jaXR5XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gc2UgcHVkbyBvYnRlbmVyIGxhIGxvY2FsaWRhZDonLCBlcnJvcilcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGNvbmV4acOzblxuICBjb25zdCBnZXRDb25uZWN0aW9uSW5mbyA9ICgpID0+IHtcbiAgICBpZiAoJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvcikge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25uZWN0aW9uVHlwZTogY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlIHx8IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgZWZmZWN0aXZlVHlwZTogY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlLFxuICAgICAgICBkb3dubGluazogY29ubmVjdGlvbi5kb3dubGluayxcbiAgICAgICAgcnR0OiBjb25uZWN0aW9uLnJ0dFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgZGV0ZWN0YXIgZGlzcG9zaXRpdm9cbiAgY29uc3QgZ2V0RGV2aWNlSW5mbyA9ICgpID0+IHtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgY29uc3QgaXNNb2JpbGUgPSAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QodXNlckFnZW50KVxuICAgIGNvbnN0IGlzVGFibGV0ID0gL2lQYWR8QW5kcm9pZCg/PS4qXFxiTW9iaWxlXFxiKSg/PS4qXFxiU2FmYXJpXFxiKS9pLnRlc3QodXNlckFnZW50KVxuICAgIGNvbnN0IGlzRGVza3RvcCA9ICFpc01vYmlsZSAmJiAhaXNUYWJsZXRcblxuICAgIHJldHVybiB7XG4gICAgICBpc01vYmlsZSxcbiAgICAgIGlzVGFibGV0LFxuICAgICAgaXNEZXNrdG9wLFxuICAgICAgdG91Y2hTdXBwb3J0OiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3dcbiAgICB9XG4gIH1cblxuICAvLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgZGF0b3MgY29tcGxldG9zIGRlIHRyYWNraW5nXG4gIGNvbnN0IGdldFRyYWNraW5nRGF0YSA9IGFzeW5jICgpOiBQcm9taXNlPFVzZXJUcmFja2luZ0RhdGE+ID0+IHtcbiAgICBjb25zdCBpcEFkZHJlc3MgPSBhd2FpdCBnZXRJUEFkZHJlc3MoKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAvLyBVSUQgw7puaWNvIGRlIGxhIHZpc2l0YVxuICAgICAgdmlzaXRVaWQ6IHZpc2l0VWlkLmN1cnJlbnQsXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZWwgbmF2ZWdhZG9yXG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBsYW5ndWFnZTogbmF2aWdhdG9yLmxhbmd1YWdlLFxuICAgICAgcGxhdGZvcm06IG5hdmlnYXRvci5wbGF0Zm9ybSxcbiAgICAgIGNvb2tpZUVuYWJsZWQ6IG5hdmlnYXRvci5jb29raWVFbmFibGVkLFxuICAgICAgZG9Ob3RUcmFjazogbmF2aWdhdG9yLmRvTm90VHJhY2ssXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZSBsYSBwYW50YWxsYVxuICAgICAgc2NyZWVuV2lkdGg6IHdpbmRvdy5zY3JlZW4ud2lkdGgsXG4gICAgICBzY3JlZW5IZWlnaHQ6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0LFxuICAgICAgdmlld3BvcnRXaWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICB2aWV3cG9ydEhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgY29sb3JEZXB0aDogd2luZG93LnNjcmVlbi5jb2xvckRlcHRoLFxuICAgICAgcGl4ZWxSYXRpbzogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZSBsYSBjb25leGnDs25cbiAgICAgIC4uLmdldENvbm5lY3Rpb25JbmZvKCksXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZSB1YmljYWNpw7NuXG4gICAgICBpcEFkZHJlc3MsXG4gICAgICBjaXR5OiBhd2FpdCBnZXRMb2NhbGlkYWQoKSwgLy8gQcOxYWRpciBsYSBjaXVkYWRcbiAgICAgIHRpbWV6b25lOiBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUsXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZSB0aWVtcG9cbiAgICAgIHNlc3Npb25TdGFydFRpbWU6IHN0YXJ0VGltZS5jdXJyZW50LFxuICAgICAgdG90YWxBY3RpdmVUaW1lOiBpc0FjdGl2ZS5jdXJyZW50ID8gdG90YWxBY3RpdmVUaW1lLmN1cnJlbnQgKyAoRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eVRpbWUuY3VycmVudCkgOiB0b3RhbEFjdGl2ZVRpbWUuY3VycmVudCxcbiAgICAgIGxhc3RBY3Rpdml0eVRpbWU6IGxhc3RBY3Rpdml0eVRpbWUuY3VycmVudCxcbiAgICAgIFxuICAgICAgLy8gSW5mb3JtYWNpw7NuIGRlIGludGVyYWNjaW9uZXNcbiAgICAgIHBhZ2VWaWV3czogcGFnZVZpZXdzLmN1cnJlbnQsXG4gICAgICBjbGlja3M6IGNsaWNrQ291bnQuY3VycmVudCxcbiAgICAgIHNjcm9sbERlcHRoOiBzY3JvbGxEZXB0aC5jdXJyZW50LFxuICAgICAgbW91c2VNb3ZlbWVudHM6IG1vdXNlTW92ZW1lbnRDb3VudC5jdXJyZW50LFxuICAgICAgXG4gICAgICAvLyBJbmZvcm1hY2nDs24gZGUgbGEgcMOhZ2luYVxuICAgICAgcmVmZXJyZXI6IGRvY3VtZW50LnJlZmVycmVyLFxuICAgICAgY3VycmVudFVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICBcbiAgICAgIC8vIEluZm9ybWFjacOzbiBkZWwgZGlzcG9zaXRpdm9cbiAgICAgIC4uLmdldERldmljZUluZm8oKSxcbiAgICAgIFxuICAgICAgLy8gSW5mb3JtYWNpw7NuIGFkaWNpb25hbFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQuY3VycmVudCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgZW52aWFyIGRhdG9zIGRlIHRyYWNraW5nXG4gIGNvbnN0IHNlbmRUcmFja2luZ0RhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gRXZpdGFyIGxsYW1hZGFzIGR1cGxpY2FkYXNcbiAgICBpZiAoaXNTZW5kaW5nLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdZYSBoYXkgdW5hIGxsYW1hZGEgZGUgdHJhY2tpbmcgZW4gcHJvZ3Jlc28sIHNhbHRhbmRvLi4uJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc1NlbmRpbmcuY3VycmVudCA9IHRydWVcbiAgICAgIGhhc1NlbnRCZWZvcmVVbmxvYWQuY3VycmVudCA9IHRydWUgLy8gTWFyY2FyIHF1ZSB5YSBzZSBlbnZpw7NcbiAgICAgIFxuICAgICAgLy8gUmVzZXRlYXIgZWwgZmxhZyBkZXNwdcOpcyBkZSA1IHNlZ3VuZG9zXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaGFzU2VudEJlZm9yZVVubG9hZC5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgY29uc29sZS5sb2coJ0ZsYWcgaGFzU2VudEJlZm9yZVVubG9hZCByZXNldGVhZG8nKVxuICAgICAgfSwgNTAwMClcbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFRyYWNraW5nRGF0YSgpXG4gICAgICBcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0VORFBPSU5UXG4gICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01FVEFfQUNDRVNTX1RPS0VOXG4gICAgICBjb25zdCBwaXhlbElkID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVUQV9QSVhFTF9JRFxuICAgICAgXG4gICAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kcG9pbnQgbm8gY29uZmlndXJhZG8nKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzIFRva2VuIG5vIGNvbmZpZ3VyYWRvJylcbiAgICAgIH1cblxuICAgICAgaWYgKCFwaXhlbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgSUQgbm8gY29uZmlndXJhZG8nKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0cmFja2luZ0RhdGE6IGRhdGEsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICBhY2Nlc3NfdG9rZW46IGFjY2Vzc1Rva2VuLFxuICAgICAgICBwaXhlbF9pZDogcGl4ZWxJZFxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7ZW5kcG9pbnR9L3RyYWNraW5nYCwgcGF5bG9hZCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZW91dDogMTAwMDBcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCdEYXRvcyBkZSB0cmFja2luZyBlbnZpYWRvcyBleGl0b3NhbWVudGU6JywgcmVzcG9uc2UuZGF0YSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVudmlhbmRvIGRhdG9zIGRlIHRyYWNraW5nOicsIGVycm9yKVxuICAgICAgLy8gRmFsbGJhY2s6IGd1YXJkYXIgZW4gbG9jYWxTdG9yYWdlXG4gICAgICBzYXZlVG9Mb2NhbFN0b3JhZ2UoKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTZW5kaW5nLmN1cnJlbnQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgZ3VhcmRhciBlbiBsb2NhbFN0b3JhZ2UgY29tbyBmYWxsYmFja1xuICBjb25zdCBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGdldFRyYWNraW5nRGF0YSgpLnRoZW4odHJhY2tpbmdEYXRhID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RyYWNraW5nRGF0YScpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBleGlzdGluZ0RhdGEgPyBKU09OLnBhcnNlKGV4aXN0aW5nRGF0YSkgOiBbXVxuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgIHRyYWNraW5nRGF0YSxcbiAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0cmFja2luZ0RhdGEnLCBKU09OLnN0cmluZ2lmeShkYXRhKSlcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGd1YXJkYW5kbyBlbiBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBlbnZpYXIgaW5pdCB0cmFja2luZ1xuICBjb25zdCBzZW5kSW5pdFRyYWNraW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEV2aXRhciBlbnbDrW9zIGR1cGxpY2Fkb3NcbiAgICBpZiAoaGFzU2VudEluaXRUcmFja2luZy5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnSW5pdCB0cmFja2luZyB5YSBmdWUgZW52aWFkbywgc2FsdGFuZG8uLi4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhhc1NlbnRJbml0VHJhY2tpbmcuY3VycmVudCA9IHRydWVcbiAgICAgIFxuICAgICAgY29uc3QgZW5kcG9pbnQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfRU5EUE9JTlRcbiAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVUQV9BQ0NFU1NfVE9LRU5cbiAgICAgIGNvbnN0IHBpeGVsSWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NRVRBX1BJWEVMX0lEXG4gICAgICBcbiAgICAgIGlmICghZW5kcG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRwb2ludCBubyBjb25maWd1cmFkbycpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHZpc2l0VWlkOiB2aXNpdFVpZC5jdXJyZW50LFxuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZC5jdXJyZW50LFxuICAgICAgICBwYWdlX2lkOiBwaXhlbElkIHx8IG51bGwsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbiB8fCBudWxsLFxuICAgICAgICBwaXhlbF9pZDogcGl4ZWxJZCB8fCBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtlbmRwb2ludH0vaW5pdC10cmFja2luZ2AsIHBheWxvYWQsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IDEwMDAwXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZygnSW5pdCB0cmFja2luZyBlbnZpYWRvIGV4aXRvc2FtZW50ZTonLCByZXNwb25zZS5kYXRhKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZW52aWFuZG8gaW5pdCB0cmFja2luZzonLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrOiBndWFyZGFyIGVuIGxvY2FsU3RvcmFnZVxuICAgICAgc2F2ZUluaXRUb0xvY2FsU3RvcmFnZSgpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgZ3VhcmRhciBpbml0IHRyYWNraW5nIGVuIGxvY2FsU3RvcmFnZSBjb21vIGZhbGxiYWNrXG4gIGNvbnN0IHNhdmVJbml0VG9Mb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbmNvbnN0IGFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVUQV9BQ0NFU1NfVE9LRU5cbiAgICAgIGNvbnN0IHBpeGVsSWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NRVRBX1BJWEVMX0lEXG4gICAgICBcbiAgICAgIGNvbnN0IGluaXREYXRhID0ge1xuICAgICAgICB2aXNpdFVpZDogdmlzaXRVaWQuY3VycmVudCxcbiAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQuY3VycmVudCxcbiAgICAgICAgcGFnZV9pZDogcGl4ZWxJZCB8fCBudWxsLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGFjY2Vzc190b2tlbjogYWNjZXNzVG9rZW4gfHwgbnVsbCxcbiAgICAgICAgcGl4ZWxfaWQ6IHBpeGVsSWQgfHwgbnVsbFxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaW5pdFRyYWNraW5nRGF0YScpXG4gICAgICBjb25zdCBkYXRhID0gZXhpc3RpbmdEYXRhID8gSlNPTi5wYXJzZShleGlzdGluZ0RhdGEpIDogW11cbiAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgIC4uLmluaXREYXRhLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnaW5pdFRyYWNraW5nRGF0YScsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuICAgICAgY29uc29sZS5sb2coJ0luaXQgdHJhY2tpbmcgZ3VhcmRhZG8gZW4gbG9jYWxTdG9yYWdlIGNvbW8gZmFsbGJhY2snKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBndWFyZGFuZG8gaW5pdCB0cmFja2luZyBlbiBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBhZ3JlZ2FyIGV2ZW50b1xuICBjb25zdCBhZGRFdmVudCA9ICh0eXBlOiBUcmFja2luZ0V2ZW50Wyd0eXBlJ10sIGRhdGE6IFBhcnRpYWw8VXNlclRyYWNraW5nRGF0YT4gPSB7fSkgPT4ge1xuICAgIGNvbnN0IGV2ZW50OiBUcmFja2luZ0V2ZW50ID0ge1xuICAgICAgdHlwZSxcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB2aXNpdFVpZDogdmlzaXRVaWQuY3VycmVudFxuICAgIH1cbiAgICBzZXRFdmVudHMocHJldiA9PiBbLi4ucHJldiwgZXZlbnRdKVxuICB9XG5cbiAgLy8gRnVuY2nDs24gcGFyYSBpbmNyZW1lbnRhciBwYWdlIHZpZXdzXG4gIGNvbnN0IGluY3JlbWVudFBhZ2VWaWV3cyA9ICgpID0+IHtcbiAgICBwYWdlVmlld3MuY3VycmVudCsrXG4gIH1cblxuICAvLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgc2Vzc2lvbiBJRFxuICBjb25zdCBnZXRTZXNzaW9uSWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHNlc3Npb25JZC5jdXJyZW50XG4gIH1cblxuICAvLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgdmlzaXQgVUlEXG4gIGNvbnN0IGdldFZpc2l0VWlkID0gKCkgPT4ge1xuICAgIHJldHVybiB2aXNpdFVpZC5jdXJyZW50XG4gIH1cblxuICAvLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgZXZlbnRvc1xuICBjb25zdCBnZXRFdmVudHMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGV2ZW50c1xuICB9XG5cbiAgLy8gVGltZXIgZnVuY3Rpb25zXG4gIGNvbnN0IHN0YXJ0VGltZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0FjdGl2ZS5jdXJyZW50KSB7XG4gICAgICBpc0FjdGl2ZS5jdXJyZW50ID0gdHJ1ZVxuICAgICAgbGFzdEFjdGl2aXR5VGltZS5jdXJyZW50ID0gRGF0ZS5ub3coKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0b3BUaW1lciA9ICgpID0+IHtcbiAgICBpZiAoaXNBY3RpdmUuY3VycmVudCkge1xuICAgICAgdG90YWxBY3RpdmVUaW1lLmN1cnJlbnQgKz0gRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eVRpbWUuY3VycmVudFxuICAgICAgaXNBY3RpdmUuY3VycmVudCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHNjcm9sbCBkZXB0aFxuICBjb25zdCB1cGRhdGVTY3JvbGxEZXB0aCA9ICgpID0+IHtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIGNvbnN0IGRvY0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBjb25zdCBzY3JvbGxQZXJjZW50ID0gKHNjcm9sbFRvcCAvIGRvY0hlaWdodCkgKiAxMDBcbiAgICBzY3JvbGxEZXB0aC5jdXJyZW50ID0gTWF0aC5tYXgoc2Nyb2xsRGVwdGguY3VycmVudCwgc2Nyb2xsUGVyY2VudClcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRXZpdGFyIG3Dumx0aXBsZXMgaW5pY2lhbGl6YWNpb25lc1xuICAgIGlmIChpc0luaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpc0luaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlXG5cbiAgICBjb25zb2xlLmxvZygnSW5pY2lhbGl6YW5kbyBUcmFja2luZyBQcm92aWRlci4uLicpXG5cbiAgICAvLyBFbnZpYXIgaW5pdCB0cmFja2luZyBpbm1lZGlhdGFtZW50ZSBjdWFuZG8gZWwgdXN1YXJpbyBlbnRyYVxuICAgIHNlbmRJbml0VHJhY2tpbmcoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbiBpbml0IHRyYWNraW5nOicsIGVycm9yKVxuICAgIH0pXG5cbiAgICAvLyBPYnRlbmVyIGRhdG9zIGluaWNpYWxlc1xuICAgIGdldFRyYWNraW5nRGF0YSgpLnRoZW4oc2V0VHJhY2tpbmdEYXRhKVxuXG4gICAgLy8gVGltZXIgZXZlbnRzXG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgICBzdGFydFRpbWVyKClcbiAgICAgIGFkZEV2ZW50KCdmb2N1cycpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlQmx1ciA9ICgpID0+IHtcbiAgICAgIHN0b3BUaW1lcigpXG4gICAgICBhZGRFdmVudCgnYmx1cicpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIHN0b3BUaW1lcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRpbWVyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTY3JvbGwgdHJhY2tpbmdcbiAgICBsZXQgc2Nyb2xsVGltZW91dDogTm9kZUpTLlRpbWVvdXRcbiAgICBjb25zdCBoYW5kbGVTY3JvbGwgPSAoKSA9PiB7XG4gICAgICB1cGRhdGVTY3JvbGxEZXB0aCgpXG4gICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZW91dClcbiAgICAgIHNjcm9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYWRkRXZlbnQoJ3Njcm9sbCcsIHsgc2Nyb2xsRGVwdGg6IHNjcm9sbERlcHRoLmN1cnJlbnQgfSlcbiAgICAgIH0sIDEwMClcbiAgICB9XG5cbiAgICAvLyBDbGljayB0cmFja2luZ1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgICAgY2xpY2tDb3VudC5jdXJyZW50KytcbiAgICAgIGFkZEV2ZW50KCdjbGljaycsIHsgY2xpY2tzOiBjbGlja0NvdW50LmN1cnJlbnQgfSlcbiAgICB9XG5cbiAgICAvLyBNb3VzZSBtb3ZlbWVudCB0cmFja2luZyAodGhyb3R0bGVkKVxuICAgIGxldCBtb3VzZVRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0XG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKCkgPT4ge1xuICAgICAgbW91c2VNb3ZlbWVudENvdW50LmN1cnJlbnQrK1xuICAgICAgY2xlYXJUaW1lb3V0KG1vdXNlVGltZW91dClcbiAgICAgIG1vdXNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAobW91c2VNb3ZlbWVudENvdW50LmN1cnJlbnQgJSAxMCA9PT0gMCkge1xuICAgICAgICAgIGFkZEV2ZW50KCdzY3JvbGwnLCB7IG1vdXNlTW92ZW1lbnRzOiBtb3VzZU1vdmVtZW50Q291bnQuY3VycmVudCB9KVxuICAgICAgICB9XG4gICAgICB9LCAxMDAwKVxuICAgIH1cblxuICAgIC8vIEJlZm9yZSB1bmxvYWRcbiAgICBjb25zdCBoYW5kbGVCZWZvcmVVbmxvYWQgPSAoKSA9PiB7XG4gICAgICBzdG9wVGltZXIoKVxuICAgICAgLy8gU29sbyBlbnZpYXIgc2kgbm8gc2UgZXN0w6EgZW52aWFuZG8geWEgWSBubyBzZSBoYSBlbnZpYWRvIHJlY2llbnRlbWVudGVcbiAgICAgIGlmICghaXNTZW5kaW5nLmN1cnJlbnQgJiYgIWhhc1NlbnRCZWZvcmVVbmxvYWQuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRW52aWFuZG8gdHJhY2tpbmcgZGF0YSBlbiBiZWZvcmV1bmxvYWQuLi4nKVxuICAgICAgICBzZW5kVHJhY2tpbmdEYXRhKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTYWx0YW5kbyBlbnbDrW8gZW4gYmVmb3JldW5sb2FkICh5YSBzZSBlbnZpw7MgcmVjaWVudGVtZW50ZSknKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhZ2UgbG9hZCB0aW1lXG4gICAgY29uc3QgaGFuZGxlTG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZykge1xuICAgICAgICBjb25zdCBsb2FkVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubG9hZEV2ZW50RW5kIC0gd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcbiAgICAgICAgYWRkRXZlbnQoJ3BhZ2VfdmlldycsIHsgcGFnZUxvYWRUaW1lOiBsb2FkVGltZSB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV2ZW50IGxpc3RlbmVyc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpXG5cbiAgICAvLyBBY3R1YWxpemFyIGRhdG9zIGNhZGEgMzAgc2VndW5kb3NcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRUcmFja2luZ0RhdGEoKVxuICAgICAgc2V0VHJhY2tpbmdEYXRhKGRhdGEpXG4gICAgfSwgMzAwMDApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0xpbXBpYW5kbyBUcmFja2luZyBQcm92aWRlci4uLicpXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSlcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljaylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgaGFuZGxlQmVmb3JlVW5sb2FkKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKVxuICAgICAgXG4gICAgICAvLyBTb2xvIGVudmlhciBkYXRvcyBhbCBkZXNtb250YXIgc2kgbm8gc2UgZXN0w6EgZW52aWFuZG8geWEgWSBubyBzZSBoYSBlbnZpYWRvIHJlY2llbnRlbWVudGVcbiAgICAgIGlmICghaXNTZW5kaW5nLmN1cnJlbnQgJiYgIWhhc1NlbnRCZWZvcmVVbmxvYWQuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRW52aWFuZG8gdHJhY2tpbmcgZGF0YSBlbiBjbGVhbnVwLi4uJylcbiAgICAgICAgc2VuZFRyYWNraW5nRGF0YSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU2FsdGFuZG8gZW52w61vIGVuIGNsZWFudXAgKHlhIHNlIGVudmnDsyByZWNpZW50ZW1lbnRlKScpXG4gICAgICB9XG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCB2YWx1ZTogVHJhY2tpbmdDb250ZXh0VHlwZSA9IHtcbiAgICB0cmFja2luZ0RhdGEsXG4gICAgc2VuZFRyYWNraW5nRGF0YSxcbiAgICBzZW5kSW5pdFRyYWNraW5nLFxuICAgIGluY3JlbWVudFBhZ2VWaWV3cyxcbiAgICBnZXRTZXNzaW9uSWQsXG4gICAgZ2V0VmlzaXRVaWQsXG4gICAgZ2V0RXZlbnRzXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUcmFja2luZ0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1RyYWNraW5nQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuXG4vLyBIb29rIHNpbXBsaWZpY2FkbyBxdWUgdXNhIGVsIGNvbnRleHRcbmV4cG9ydCBjb25zdCB1c2VVc2VyVHJhY2tpbmcgPSAoKTogVHJhY2tpbmdDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRyYWNraW5nQ29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlVXNlclRyYWNraW5nIGRlYmUgc2VyIHVzYWRvIGRlbnRybyBkZSBUcmFja2luZ1Byb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiYXhpb3MiLCJUcmFja2luZ0NvbnRleHQiLCJ1bmRlZmluZWQiLCJUcmFja2luZ1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJ0cmFja2luZ0RhdGEiLCJzZXRUcmFja2luZ0RhdGEiLCJldmVudHMiLCJzZXRFdmVudHMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwidG90YWxBY3RpdmVUaW1lIiwibGFzdEFjdGl2aXR5VGltZSIsImlzQWN0aXZlIiwic2Vzc2lvbklkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidmlzaXRVaWQiLCJtb3VzZU1vdmVtZW50Q291bnQiLCJjbGlja0NvdW50Iiwic2Nyb2xsRGVwdGgiLCJwYWdlVmlld3MiLCJpc1NlbmRpbmciLCJpc0luaXRpYWxpemVkIiwiaGFzU2VudEJlZm9yZVVubG9hZCIsImhhc1NlbnRJbml0VHJhY2tpbmciLCJnZXRJUEFkZHJlc3MiLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJpcCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRMb2NhbGlkYWQiLCJjaXR5IiwiZ2V0Q29ubmVjdGlvbkluZm8iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwiY29ubmVjdGlvblR5cGUiLCJlZmZlY3RpdmVUeXBlIiwidHlwZSIsImRvd25saW5rIiwicnR0IiwiZ2V0RGV2aWNlSW5mbyIsInVzZXJBZ2VudCIsImlzTW9iaWxlIiwidGVzdCIsImlzVGFibGV0IiwiaXNEZXNrdG9wIiwidG91Y2hTdXBwb3J0Iiwid2luZG93IiwiZ2V0VHJhY2tpbmdEYXRhIiwiaXBBZGRyZXNzIiwiY3VycmVudCIsImxhbmd1YWdlIiwicGxhdGZvcm0iLCJjb29raWVFbmFibGVkIiwiZG9Ob3RUcmFjayIsInNjcmVlbldpZHRoIiwic2NyZWVuIiwid2lkdGgiLCJzY3JlZW5IZWlnaHQiLCJoZWlnaHQiLCJ2aWV3cG9ydFdpZHRoIiwiaW5uZXJXaWR0aCIsInZpZXdwb3J0SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJjb2xvckRlcHRoIiwicGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJ0aW1lem9uZSIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInJlc29sdmVkT3B0aW9ucyIsInRpbWVab25lIiwic2Vzc2lvblN0YXJ0VGltZSIsImNsaWNrcyIsIm1vdXNlTW92ZW1lbnRzIiwicmVmZXJyZXIiLCJkb2N1bWVudCIsImN1cnJlbnRVcmwiLCJsb2NhdGlvbiIsImhyZWYiLCJ0aW1lc3RhbXAiLCJzZW5kVHJhY2tpbmdEYXRhIiwibG9nIiwic2V0VGltZW91dCIsImVuZHBvaW50IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9FTkRQT0lOVCIsImFjY2Vzc1Rva2VuIiwiTkVYVF9QVUJMSUNfTUVUQV9BQ0NFU1NfVE9LRU4iLCJwaXhlbElkIiwiTkVYVF9QVUJMSUNfTUVUQV9QSVhFTF9JRCIsIkVycm9yIiwicGF5bG9hZCIsImFjY2Vzc190b2tlbiIsInBpeGVsX2lkIiwicG9zdCIsImhlYWRlcnMiLCJ0aW1lb3V0Iiwic2F2ZVRvTG9jYWxTdG9yYWdlIiwidGhlbiIsImV4aXN0aW5nRGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInNlbmRJbml0VHJhY2tpbmciLCJwYWdlX2lkIiwic2F2ZUluaXRUb0xvY2FsU3RvcmFnZSIsImluaXREYXRhIiwiY3JlYXRlZF9hdCIsInRvSVNPU3RyaW5nIiwiYWRkRXZlbnQiLCJldmVudCIsInByZXYiLCJpbmNyZW1lbnRQYWdlVmlld3MiLCJnZXRTZXNzaW9uSWQiLCJnZXRWaXNpdFVpZCIsImdldEV2ZW50cyIsInN0YXJ0VGltZXIiLCJzdG9wVGltZXIiLCJ1cGRhdGVTY3JvbGxEZXB0aCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jSGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsUGVyY2VudCIsIm1heCIsImNhdGNoIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlTdGF0ZSIsInNjcm9sbFRpbWVvdXQiLCJoYW5kbGVTY3JvbGwiLCJjbGVhclRpbWVvdXQiLCJoYW5kbGVDbGljayIsIm1vdXNlVGltZW91dCIsImhhbmRsZU1vdXNlTW92ZSIsImhhbmRsZUJlZm9yZVVubG9hZCIsImhhbmRsZUxvYWQiLCJwZXJmb3JtYW5jZSIsInRpbWluZyIsImxvYWRUaW1lIiwibG9hZEV2ZW50RW5kIiwibmF2aWdhdGlvblN0YXJ0IiwicGFnZUxvYWRUaW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VVc2VyVHJhY2tpbmciLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/context/tracking-context.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/metaEventService.ts":
/*!**************************************!*\
  !*** ./services/metaEventService.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sendMetaEvent: function() { return /* binding */ sendMetaEvent; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nasync function sendMetaEvent(email) {\n    let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"10\";\n    console.log(\"\\uD83D\\uDE80 Iniciando env\\xedo de evento a Meta...\");\n    console.log(\"\\uD83D\\uDCE7 Email:\", email);\n    console.log(\"\\uD83D\\uDCB0 Valor:\", value);\n    try {\n        const eventData = {\n            event_name: \"Purchase\",\n            event_time: Math.floor(Date.now() / 1000),\n            action_source: \"website\",\n            user_data: {\n                em: [\n                    \"7b17fb0bd173f625b58636fb796407c22b3d16fc78302d79f0fd30c2fc2fc068\"\n                ]\n            },\n            custom_data: {\n                currency: \"USD\",\n                value: value\n            }\n        };\n        console.log(\"\\uD83D\\uDCCA Event data preparado:\", eventData);\n        const accessToken = \"EAAOHUgAkJWEBPHk7PAlWlSFEaIW3UBDhGn87Q6DipWvRt0gXptWxF0N9bqEvGdayqRiC3OClsQbztOXhQhk4vXTXfNv12vFE2yQfeQii5CEGXkmgpZCeG1dwKYq83anh4zvUHMrXnqhILBZBbDDkzsfy2s8eD0ZBz8gL1oy60rfzpaC7CeT8Gq9EkQ4luk6OQZDZD\";\n        const pixelId = \"1374845580367644\";\n        const endpoint = \"http://localhost:3003/send-event\";\n        console.log(\"\\uD83D\\uDD27 Variables de entorno:\");\n        console.log(\"  - Endpoint:\", endpoint ? \"✅ Configurado\" : \"❌ No configurado\");\n        console.log(\"  - Access Token:\", accessToken ? \"✅ Configurado\" : \"❌ No configurado\");\n        console.log(\"  - Pixel ID:\", pixelId ? \"✅ Configurado\" : \"❌ No configurado\");\n        if (!endpoint) {\n            throw new Error(\"Endpoint no configurado\");\n        }\n        if (!accessToken) {\n            throw new Error(\"Access Token no configurado\");\n        }\n        if (!pixelId) {\n            throw new Error(\"Pixel ID no configurado\");\n        }\n        const payload = {\n            eventData,\n            accessToken,\n            pixelId\n        };\n        console.log(\"\\uD83D\\uDCE4 Enviando payload a:\", endpoint);\n        console.log(\"\\uD83D\\uDCE6 Payload:\", JSON.stringify(payload, null, 2));\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(endpoint, payload, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            timeout: 10000\n        });\n        console.log(\"✅ Evento enviado exitosamente:\", response.data);\n        return true;\n    } catch (error) {\n        var _error_response, _error_response1;\n        console.error(\"❌ Error enviando evento a Meta:\");\n        console.error(\"  - Tipo de error:\", error.name);\n        console.error(\"  - Mensaje:\", error.message);\n        console.error(\"  - Response status:\", (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status);\n        console.error(\"  - Response data:\", (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data);\n        console.error(\"  - Stack:\", error.stack);\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL21ldGFFdmVudFNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFlbkIsZUFBZUMsY0FBY0MsS0FBYTtRQUFFQyxRQUFBQSxpRUFBZ0I7SUFDakVDLFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUMsdUJBQWFIO0lBQ3pCRSxRQUFRQyxHQUFHLENBQUMsdUJBQWFGO0lBRXpCLElBQUk7UUFDRixNQUFNRyxZQUEyQjtZQUMvQkMsWUFBWTtZQUNaQyxZQUFZQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztZQUNwQ0MsZUFBZTtZQUNmQyxXQUFXO2dCQUNUQyxJQUFJO29CQUFDO2lCQUFtRTtZQUMxRTtZQUNBQyxhQUFhO2dCQUNYQyxVQUFVO2dCQUNWZCxPQUFPQTtZQUNUO1FBQ0Y7UUFFQUMsUUFBUUMsR0FBRyxDQUFDLHNDQUE0QkM7UUFFeEMsTUFBTVksY0FBY0Msd01BQXlDO1FBQzdELE1BQU1HLFVBQVVILGtCQUFxQztRQUNyRCxNQUFNSyxXQUFXTCxrQ0FBb0M7UUFFckRmLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsaUJBQWlCbUIsV0FBVyxrQkFBa0I7UUFDMURwQixRQUFRQyxHQUFHLENBQUMscUJBQXFCYSxjQUFjLGtCQUFrQjtRQUNqRWQsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQmlCLFVBQVUsa0JBQWtCO1FBRXpELElBQUksQ0FBQ0UsVUFBVTtZQUNiLE1BQU0sSUFBSUUsTUFBTTtRQUNsQjtRQUVBLElBQUksQ0FBQ1IsYUFBYTtZQUNoQixNQUFNLElBQUlRLE1BQU07UUFDbEI7UUFFQSxJQUFJLENBQUNKLFNBQVM7WUFDWixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxVQUFVO1lBQ2RyQjtZQUNBWTtZQUNBSTtRQUNGO1FBRUFsQixRQUFRQyxHQUFHLENBQUMsb0NBQTBCbUI7UUFDdENwQixRQUFRQyxHQUFHLENBQUMseUJBQWV1QixLQUFLQyxTQUFTLENBQUNGLFNBQVMsTUFBTTtRQUV6RCxNQUFNRyxXQUFXLE1BQU05Qiw2Q0FBS0EsQ0FBQytCLElBQUksQ0FBQ1AsVUFBVUcsU0FBUztZQUNuREssU0FBUztnQkFDUCxnQkFBZ0I7WUFDbEI7WUFDQUMsU0FBUztRQUNYO1FBRUE3QixRQUFRQyxHQUFHLENBQUMsa0NBQWtDeUIsU0FBU0ksSUFBSTtRQUMzRCxPQUFPO0lBQ1QsRUFBRSxPQUFPQyxPQUFZO1lBSW1CQSxpQkFDRkE7UUFKcEMvQixRQUFRK0IsS0FBSyxDQUFDO1FBQ2QvQixRQUFRK0IsS0FBSyxDQUFDLHNCQUFzQkEsTUFBTUMsSUFBSTtRQUM5Q2hDLFFBQVErQixLQUFLLENBQUMsZ0JBQWdCQSxNQUFNRSxPQUFPO1FBQzNDakMsUUFBUStCLEtBQUssQ0FBQyx5QkFBd0JBLGtCQUFBQSxNQUFNTCxRQUFRLGNBQWRLLHNDQUFBQSxnQkFBZ0JHLE1BQU07UUFDNURsQyxRQUFRK0IsS0FBSyxDQUFDLHVCQUFzQkEsbUJBQUFBLE1BQU1MLFFBQVEsY0FBZEssdUNBQUFBLGlCQUFnQkQsSUFBSTtRQUN4RDlCLFFBQVErQixLQUFLLENBQUMsY0FBY0EsTUFBTUksS0FBSztRQUN2QyxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zZXJ2aWNlcy9tZXRhRXZlbnRTZXJ2aWNlLnRzP2FiYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuaW50ZXJmYWNlIE1ldGFFdmVudERhdGEge1xuICBldmVudF9uYW1lOiBzdHJpbmc7XG4gIGV2ZW50X3RpbWU6IG51bWJlcjtcbiAgYWN0aW9uX3NvdXJjZTogc3RyaW5nO1xuICB1c2VyX2RhdGE6IHtcbiAgICBlbTogc3RyaW5nW107XG4gIH07XG4gIGN1c3RvbV9kYXRhOiB7XG4gICAgY3VycmVuY3k6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZE1ldGFFdmVudChlbWFpbDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nID0gXCIxMFwiKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnNvbGUubG9nKCfwn5qAIEluaWNpYW5kbyBlbnbDrW8gZGUgZXZlbnRvIGEgTWV0YS4uLicpO1xuICBjb25zb2xlLmxvZygn8J+TpyBFbWFpbDonLCBlbWFpbCk7XG4gIGNvbnNvbGUubG9nKCfwn5KwIFZhbG9yOicsIHZhbHVlKTtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgZXZlbnREYXRhOiBNZXRhRXZlbnREYXRhID0ge1xuICAgICAgZXZlbnRfbmFtZTogXCJQdXJjaGFzZVwiLFxuICAgICAgZXZlbnRfdGltZTogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICBhY3Rpb25fc291cmNlOiBcIndlYnNpdGVcIixcbiAgICAgIHVzZXJfZGF0YToge1xuICAgICAgICBlbTogW1wiN2IxN2ZiMGJkMTczZjYyNWI1ODYzNmZiNzk2NDA3YzIyYjNkMTZmYzc4MzAyZDc5ZjBmZDMwYzJmYzJmYzA2OFwiXVxuICAgICAgfSxcbiAgICAgIGN1c3RvbV9kYXRhOiB7XG4gICAgICAgIGN1cnJlbmN5OiBcIlVTRFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogRXZlbnQgZGF0YSBwcmVwYXJhZG86JywgZXZlbnREYXRhKTtcblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVUQV9BQ0NFU1NfVE9LRU47XG4gICAgY29uc3QgcGl4ZWxJZCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01FVEFfUElYRUxfSUQ7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfRU5EUE9JTlQ7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflKcgVmFyaWFibGVzIGRlIGVudG9ybm86Jyk7XG4gICAgY29uc29sZS5sb2coJyAgLSBFbmRwb2ludDonLCBlbmRwb2ludCA/ICfinIUgQ29uZmlndXJhZG8nIDogJ+KdjCBObyBjb25maWd1cmFkbycpO1xuICAgIGNvbnNvbGUubG9nKCcgIC0gQWNjZXNzIFRva2VuOicsIGFjY2Vzc1Rva2VuID8gJ+KchSBDb25maWd1cmFkbycgOiAn4p2MIE5vIGNvbmZpZ3VyYWRvJyk7XG4gICAgY29uc29sZS5sb2coJyAgLSBQaXhlbCBJRDonLCBwaXhlbElkID8gJ+KchSBDb25maWd1cmFkbycgOiAn4p2MIE5vIGNvbmZpZ3VyYWRvJyk7XG4gICAgXG4gICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRwb2ludCBubyBjb25maWd1cmFkbycpO1xuICAgIH1cblxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjZXNzIFRva2VuIG5vIGNvbmZpZ3VyYWRvJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwaXhlbElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIElEIG5vIGNvbmZpZ3VyYWRvJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGV2ZW50RGF0YSxcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgcGl4ZWxJZFxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygn8J+TpCBFbnZpYW5kbyBwYXlsb2FkIGE6JywgZW5kcG9pbnQpO1xuICAgIGNvbnNvbGUubG9nKCfwn5OmIFBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMikpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGVuZHBvaW50LCBwYXlsb2FkLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgdGltZW91dDogMTAwMDBcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCfinIUgRXZlbnRvIGVudmlhZG8gZXhpdG9zYW1lbnRlOicsIHJlc3BvbnNlLmRhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGVudmlhbmRvIGV2ZW50byBhIE1ldGE6Jyk7XG4gICAgY29uc29sZS5lcnJvcignICAtIFRpcG8gZGUgZXJyb3I6JywgZXJyb3IubmFtZSk7XG4gICAgY29uc29sZS5lcnJvcignICAtIE1lbnNhamU6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgY29uc29sZS5lcnJvcignICAtIFJlc3BvbnNlIHN0YXR1czonLCBlcnJvci5yZXNwb25zZT8uc3RhdHVzKTtcbiAgICBjb25zb2xlLmVycm9yKCcgIC0gUmVzcG9uc2UgZGF0YTonLCBlcnJvci5yZXNwb25zZT8uZGF0YSk7XG4gICAgY29uc29sZS5lcnJvcignICAtIFN0YWNrOicsIGVycm9yLnN0YWNrKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0gIl0sIm5hbWVzIjpbImF4aW9zIiwic2VuZE1ldGFFdmVudCIsImVtYWlsIiwidmFsdWUiLCJjb25zb2xlIiwibG9nIiwiZXZlbnREYXRhIiwiZXZlbnRfbmFtZSIsImV2ZW50X3RpbWUiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiYWN0aW9uX3NvdXJjZSIsInVzZXJfZGF0YSIsImVtIiwiY3VzdG9tX2RhdGEiLCJjdXJyZW5jeSIsImFjY2Vzc1Rva2VuIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX01FVEFfQUNDRVNTX1RPS0VOIiwicGl4ZWxJZCIsIk5FWFRfUFVCTElDX01FVEFfUElYRUxfSUQiLCJlbmRwb2ludCIsIk5FWFRfUFVCTElDX0FQSV9FTkRQT0lOVCIsIkVycm9yIiwicGF5bG9hZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsInBvc3QiLCJoZWFkZXJzIiwidGltZW91dCIsImRhdGEiLCJlcnJvciIsIm5hbWUiLCJtZXNzYWdlIiwic3RhdHVzIiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/metaEventService.ts\n"));

/***/ })

});